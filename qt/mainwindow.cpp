// #include <QApplication>
#include "mainwindow.h"
#include "qapplication.h"

#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QSplitter>
#include <QPushButton>
#include <systemc.h>
#include <pthread.h>
#include <QList>
#include <iostream>
#include "scqt_worker.h"


// -------------- From "How do I create a pause/wait function using Qt?" -----
// -------------- https://stackoverflow.com/questions/3752742/how-do-i-create-a-pause-wait-function-using-qt -----
// -------------- answered Mar 24, 2017 at 15:18 by dvntehn00bz -----------------
#include <QEventLoop>
#include <QTimer>
inline void delay(int millisecondsWait)
{
    QEventLoop loop;
    QTimer t;
    t.connect(&t, &QTimer::timeout, &loop, &QEventLoop::quit);
    t.start(millisecondsWait);
    loop.exec();
}

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , m_scqtThread(nullptr)
    , m_scqtWorker(nullptr)
    , ui(new Ui::MainWindow)
{
     connect(this, &MainWindow::Message, this, &MainWindow::onMessage);

//    setupUi();
    ui->setupUi(this);
    setupSim();


    SVGs = new SVG_Viewer(NULL);
    SVGs->getScene()->addItem (SVGs->getTxt());
    ui->graphicsView->setScene(SVGs->getScene());
    ui->graphicsView->show();
    QObject::connect(ui->verticalSlider, SIGNAL( valueChanged(int) ), SVGs, SLOT(on_verticalSlider_valueChanged(int)));
}

MainWindow::~MainWindow()
{
}


/* SVG rendering is updated in this function (each time the "clock" button is pressed).
 * A first mode where lists are initialized: case where 'logMessage.contains("Report received: 0 s")
 * This involves a search for correspondences between systemC components and SVG file elements.
 *
 * Another mode where rendering is updated according to the string generated by systemC: case where logMessage.contains("Report received")
 * SVG element list values are updated according to the values (after the '=' sign) contained in the strDom string array
 */
void MainWindow::onMessage(QString const &msg_origin, QString const &msg_level, QString const &msg)
{
    QString logMessage(msg_level);
//    QStringList strDom;
//    QList<QDomElement> listElem;
    QDomElement elem;
    logMessage.append(" msg (").append(msg_origin).append(") :: ").append(msg);
//    logConsole->append(logMessage);
    ui->textBrowser->append(logMessage);

    if(logMessage.contains("Report received: 0 s"))
    {

        ui->textBrowser->append("Report received time 0 : findDomelements related to SVG file and value processing");
        *(SVGs->getStrDom()) = logMessage.split(", "); /* Loading hierarchy elements (string) */
//        *(SVGs->getPrior_value()) = *(SVGs->getStrDom());

        /* Visual console of hierarchy elements (character string) */
        for(int i = 0 ; i< (SVGs->getStrDom())->length() ; i++)
        {
            ui->textBrowser->append((SVGs->getStrDom())->at(i));
        }

        SVGs->getStrDom()->removeFirst(); // Deleting the first element corresponding to a systemC message

        /* DOM loading based on string array elements */
        ui->textBrowser->append("");
        ui->textBrowser->append("Find elements!");
        for(int i = 0 ; i<(SVGs->getStrDom())->length() ; i++)
        {
            elem = findDomElement("svg30:layer1:STROKES:"+ ((SVGs->getStrDom())->at(i).split("=").at(0)), *(SVGs->getDom()));
            if(!(elem).isNull())
            {
                SVGs->getPrior_value()->append((SVGs->getStrDom())->at(i));
                SVGs->getIndex_elem()->append(i);
                SVGs->getListElem()->append(elem); // Add element only when non-zero
            }
        }

        /* Visual for all SVG elements found */
        std::cout<<std::endl;
        std::cout<<"Display found elements and its index value!"<<std::endl;

        for(int i = 0 ; i<SVGs->getListElem()->length() ; i++)
        {
//            ui->textBrowser->append(SVGs->getListElem()->at(i).attribute("id"));
//            ui->textBrowser->append((SVGs->getIndex_elem()->at(i)));

            std::cout<<"el:"<<SVGs->getListElem()->at(i).attribute("id").toStdString()<<" ; index:"<<(SVGs->getIndex_elem()->at(i))<<std::endl;
        }
    }

    else if(logMessage.contains("Report received"))
    {
        *(SVGs->getStrDom()) = logMessage.split(", "); /* Loading hierarchy elements (string) */
        SVGs->getStrDom()->removeFirst(); // Deleting the first element corresponding to a systemC message

        ui->textBrowser->append("Report received time > 0 : only value processing");
//        setTextDomElementSim((QDomElement*)&(SVGs->getListElem()->at(12)), (SVGs->getStrDom())->at(12).split("=").at(1));

        /* Updating values */
        for(int i=0 ; i<SVGs->getIndex_elem()->length() ; i++)
        {
//            std::cout<<"12:"<<SVGs->getListElem()->at(i).attribute("id").toStdString()<<std::endl;
            setTextDomElementSim((SVGs->getListElem()->at(i)), (SVGs->getStrDom())->at(SVGs->getIndex_elem()->at(i)).split("=").at(1));

        }

        /* Scans all elements of the strDom, listElem and prior_value lists to detect a change in value, thus changing the color of the thread (red). */
        for(int i=0 ; i<SVGs->getIndex_elem()->length() ; i++)
        {
            if((SVGs->getPrior_value()->at(i)) != ((SVGs->getStrDom())->at(SVGs->getIndex_elem()->at(i))))
            {
                std::cout<<"12:"<<(SVGs->getPrior_value()->at(i)).toStdString()<<std::endl;
                setColorDomElement((SVGs->getListElem()->at(i)), "ff0000");
            }
        }

        /* Update priority_value */
        for(int i=0 ; i<SVGs->getIndex_elem()->length() ; i++)
        {
            std::cout<<"actual:"<<((SVGs->getStrDom())->at(SVGs->getIndex_elem()->at(i))).toStdString()<<" ; prior:"<<(SVGs->getPrior_value()->at(i)).toStdString()<<std::endl;
            (SVGs->getPrior_value())->replace(i, (SVGs->getStrDom())->at(SVGs->getIndex_elem()->at(i)));
        }


        SVGs->refresh();
    }
}

//void MainWindow::onResetClicked(bool checked)
//{
//    (void)checked;
//    _sendMessage("DEBUG", "Reset clicked");
//}

void MainWindow::on_pushButton_clicked(bool checked)
{
    (void)checked;
    _sendMessage("DEBUG", "Reset clicked");
}

//void MainWindow::onClockClicked(bool checked)
//{
//    (void)checked;
//    _sendMessage("DEBUG", "Clock clicked");
//    if (m_scqtWorker != nullptr) {
//        emit setNewState(SC_ST_COMMAND_RUN);
//        emit requestReport();
//    }
//}

void MainWindow::on_pushButton_3_clicked(bool checked)
{
    (void)checked;
    _sendMessage("DEBUG", "Clock clicked");
    if (m_scqtWorker != nullptr) {
        emit setNewState(SC_ST_COMMAND_RUN);
        emit requestReport();
    }
}

void MainWindow::on_pushButton_2_clicked(bool checked)
{
    (void)checked;
    _sendMessage("DEBUG", "Exit clicked, terminating program");
    if (m_scqtWorker != nullptr) {
        emit setNewState(SC_ST_COMMAND_EXIT);
    }
    delay(1000);
    QApplication::quit();
}

void MainWindow::newHierarchy(QStringList hier)
{
    QString debugMsg("Hierarchy received:");
    for (qsizetype i=0; i<hier.size(); i++) {
        if (i == 0) {
            debugMsg.append(" ");

        } else {
            debugMsg.append(", ");
        }
        debugMsg.append(hier.at(i));
    }
    _sendMessage("DEBUG", debugMsg);
}

void MainWindow::newReport(QStringList rep)
{
    QString debugMsg("Report received:");
    for (qsizetype i=0; i<rep.size(); i++) {
        if (i == 0) {
            debugMsg.append(" ");
        } else {
            debugMsg.append(", ");
        }
        debugMsg.append(rep.at(i));
    }
    _sendMessage("DEBUG", debugMsg);
}

void MainWindow::_sendMessage(QString const &msg_level, QString const &msg)
{
    emit Message("GUI", msg_level, msg);

    // emit Message("DEBUG", msg_level, msg_upper);
}

void MainWindow::setupUi()
{
    QGridLayout *gridLayout = new QGridLayout;
    QPushButton *btnReset;
    QPushButton *btnClock;
    QPushButton *btnExit;

    QWidget *cWidget = new QWidget();
    setCentralWidget(cWidget);
    centralWidget()->setLayout(gridLayout);
    btnReset = new QPushButton("Reset");
    connect(btnReset, &QPushButton::clicked, this, &MainWindow::on_pushButton_clicked);
    btnClock = new QPushButton("Clock");
    connect(btnClock, &QPushButton::clicked, this, &MainWindow::on_pushButton_3_clicked);
    btnExit = new QPushButton("Exit");
    connect(btnExit, &QPushButton::clicked, this, &MainWindow::on_pushButton_2_clicked);

//    logConsole = new QTextBrowser();

    // Layout grid
    // First row:   <Reset>  ...splitter...  <Clock>
    // Second row:  <          logConsole          >
    // Third row:   <Exit>
    gridLayout->addWidget(btnReset, 0, 0);
    gridLayout->addWidget(new QSplitter(Qt::Horizontal), 0, 1);
    gridLayout->addWidget(btnClock, 0, 2);
//    gridLayout->addWidget(logConsole, 2, 0, 1, 3); // Span the three columns
    gridLayout->addWidget(btnExit, 3, 0);

    setWindowTitle("SystemC Test");
}

void MainWindow::setupSim()
{
    m_scqtThread = new QThread;
    m_scqtWorker = new scQtWorker;
    m_scqtWorker->moveToThread(m_scqtThread);

    // Prepare config parameters
    m_ConfigParams.rst_act_level = false; // Reset: low-level active
    m_ConfigParams.rst_act_microsteps = 20; // Reset active for 25 usteps (2.5 clock periods)
    m_ConfigParams.clk_act_edge  = false; // Clock: falling-edge sensitive
    m_ConfigParams.ena_act_level = true;  // Enable: high-level active
    m_ConfigParams.clk_period = sc_time(10, SC_NS);   // CLock period: 10 ns
    m_ConfigParams.clk_semiperiod_microsteps = 4;
    m_ConfigParams.microstep = m_ConfigParams.clk_period/m_ConfigParams.clk_semiperiod_microsteps;

    m_scqtWorker->setConfigParameters(m_ConfigParams);

    connect(m_scqtThread, &QThread::started, m_scqtWorker, &scQtWorker::doStart);

    connect(m_scqtWorker, &scQtWorker::Message, this, &MainWindow::onMessage);
    connect(this, &MainWindow::setNewState, m_scqtWorker, &scQtWorker::setNewState);
    connect(this, &MainWindow::requestHierarchy, m_scqtWorker, &scQtWorker::getHierarchy);
    connect(this, &MainWindow::requestReport, m_scqtWorker, &scQtWorker::getReport);
    connect(this, &MainWindow::setTraceList, m_scqtWorker, &scQtWorker::setTraceList);
    connect(m_scqtWorker, &scQtWorker::signalHierarchy, this, &MainWindow::newHierarchy);
    connect(m_scqtWorker, &scQtWorker::signalReport, this, &MainWindow::newReport);

    m_scqtThread->start();

    emit setNewState(SC_ST_COMMAND_RUN);
    emit requestHierarchy();
}



void MainWindow::Refresh()
{
    ui->graphicsView->update();
}

void MainWindow::on_checkBox_clicked(bool checked)
{
    std::cout<<"clicked"<<std::endl;
    if(checked)
    {
        for(int i=0 ; i<SVGs->getIndex_elem()->length() ; i++)
        {
//            showDomElementSim(SVGs->getListElem()->at(i));
            setStyleAttrDomElementSim(SVGs->getListElem()->at(i), "display:inline");
        }
    }

    else
    {
        for(int i=0 ; i<SVGs->getIndex_elem()->length() ; i++)
        {
//            hideDomElementSim(SVGs->getListElem()->at(i));
            setStyleAttrDomElementSim(SVGs->getListElem()->at(i), "display:none");
        }
    }

    SVGs->refresh();
}


/*
 * Not used for this simulation
 */
void MainWindow::on_actionExit_triggered()
{

}



/* Function called when user clicks on 'file' > 'Open Source
 *
 */
void MainWindow::on_actionOpen_source_triggered()
{
    /* The files displayed in the dialog box are only those whose extension is set in the 2nd parameter (txt and asm).  */
    QString link = WinSelectFile.getOpenFileName(this, tr("Select Source file)"), "C:/", tr("Assembler Files (*.asm *.txt)"));

    std::cout<<link.toStdString()<<std::endl;

    QFile asmf(link);

    asmf.open(QIODevice::ReadOnly);

    /* The contents of the file go into this Widget */
    ui->TextEditor->setPlainText(asmf.readAll());
}

